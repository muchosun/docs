# Drone Master Messenger

Данный модуль испльзуется для организации управления дроном с помощью мессенджера, посылающего команды.

## messenger.py

В этом модуле описываются классы и методы, необходимые для огранизации полета и работы дрона с помощью базы данных.

Файл модуля использует библиотеку SQLAlchemy для работы с базами данных SQL: загружается необходимый механизм создания базы данных и ее API, определение декларативных классов и механизм общения с базой данных. Также подключаются модули rospy и os.

```python
from sqlalchemy import create_engine, Column, Integer, String, Sequence, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm.session import sessionmaker
import rospy, os
```

В начале объявляется класс декларативной база данных:

```python
Base = declarative_base()
```

Затем в модуле объявляются три класса, который конфигурируют таблицы с метаданными:

* `DroneMove(Base)` — класс с таблицей, хранящая информацию о передвижении определенного дрона в указанную точку.
* `DroneFree(Base)` — класс, который хранит необходимую информацию при заверешении работы дрона.
* `DroneLink(Base)` — класс с информаций о закреплении за определенным дроном и соответствующим адаптером ссылки на IFPS файл.

В классе `DroneMove()` задается соответствующее имя таблицы `drone_move` с данными о ID, дроне и целевой точке.

Разберем, как определяется класс `DroneFree()`. В начале задается соответствующее имя таблицы `drone_free` с данными о ID и дроне, который завершил свою работу. Конструктор же определяет, какой адаптер отвечает за этого дрона:

```python
def __init__(self, adapter):
    self.drone = adapter
```

Разберем, как определяется класс `DroneLink()`. В начале задается соответствующее имя таблицы `drone_link` с данными о ID, дроне и ссылке на миссию дрона в IPFS. Конструктор же определяет, какой адаптер отвечает за этого дрона и инициализирует ссылку IPFS:

```python
def __init__(self, adapter, link):
    self.drone = adapter
    self.link  = link
```

Теперь рассмотрим методы модуля *messenger.py*:

* `spawn_db()` — отвечает за инициализацию соединения с базой данных;
* `messenger_drone_free(adapter)` — отвечает за добавление записей в базу данных о прекращении работы дрона;
* `messenger_drone_link(adapter, link)` — отвечает за добавление записей в базу данных о закреплении за дроном и соответствующим адаптером ссылки на IFPS файл;
* `messenger_mission_gen(adapter)` — отвечает за организацию передвижения дрона и отправку соответствуюих записей в базу данных.

Разберем метод `spawn_db()` детально:

```python
db = create_engine(os.environ['DB_CONN_STRING'], client_encoding='utf8')
return sessionmaker(bind=db)()
```
Метод `create_engine()` создает экземляр класса Engine, отвечающий за соединение с СУБД: он интерпретируют функции API базы данных и определяет ее поведение. Адрес соединения подгружается из переменной среды `DB_CONN_STRING`. Метод возвращает фабрику объектов `Session`, которые отвечают за работу ORM.

Разберем метод `messenger_drone_free()` детально. Сначала он устанавливает соединение с базой данных с помощью определенного ранее метода `spawn_db()`. Далее проверяется запрос о заверешении работы адаптера, закрепленного за дроном, а затем соответствующая запись добавляется в базу данных с помощью ранее определенного класса `DroneFree()`:

```python
if not db.query(DroneFree).filter_by(drone=adapter).first():
    db.add(DroneFree(adapter))
    db.commit()
```

Разберем метод `messenger_drone_link()` детально. Сначала он устанавливает соединение с базой данных с помощью определенного ранее метода `spawn_db()`. Затем запись о ссылки добавляется в базу данных с помощью ранее определенного класса `DroneLink()`:

```python
db.add(DroneLink(adapter, link))
db.commit()
```

Разберем метод `messenger_mission_gen()` детально. Для начала метод проверяет, запущенно ли ядро ROS, чтобы иметь возможность давать команды на передивижение дрону:

```python
while not rospy.is_shutdown():
```

Затем метод организует считывание и проверку запросов о передвижении в заданную точку, сепарируя полученные данные о точке полета с помощью условного оператора:

```python
act = db.query(DroneMove).filter_by(drone=adapter).first()
if act.point == 'A':
  yield 2
elif act.point == 'B':
  yield 3
elif act.point == 'C':
  yield 4
elif act.point == 'Home':
  yield (-1)
```
Если обработка запроса проходит успешно, то соответствующая запись делается в базу данных. В ином случае модуль сигнализирует об ошибке, закрывает соединение с базой данных и ждет следующего запроса.

*Примечание*. Проверить логику работы классов и методов.

## master.py

Этот модуль организует работу всего дрона, исходя из полученных от пользователя команд.

Файл модуля использует заголовочные файлы сообщений и сервисов MAVROS - коммуникационного драйвера протокола связи MAVLink для ROS. В частности подключаются тип сообщений `State`, который кодирует текущее состояние автопилота дрона. Также подключаются следующие сервисы: сервис `WaypointSetCurrent`, запрашивающий текущую путевую точку дрона; сервис `CommandBool` отвечает за переключение команд,  `CommandTOL` используется для взлета и посадки, `SetMode` устанавливает режимы блока управления полетом (Flight Controller Unit).

```python
from mavros_msgs.srv import CommandBool, CommandTOL, SetMode
from mavros_msgs.srv import WaypointSetCurrent
from mavros_msgs.msg import State
```

Подключаются файлы библиотек сообщений и сервисов ROS:

```python
from std_srvs.srv import SetBool
from std_msgs.msg import String, UInt32
```
Также подгружаются ранее созданные модули:

```python
from messenger import messenger_mission_gen
from messenger import messenger_drone_free
```
Создаются пустой лист `adapters` и словарь `states`, которые будут хранить в себе данные о адаптерах и состояниях пилотирования.

```python
adapters = []
states = {}
```

Теперь рассмотрим методы модуля *master.py*:

* `set_mode(adapter, mode)` — устанавливает новый режим автопилота в блок управления полетами;
* `arming(adapter)` — отвечает за изменение команды отправки дрона;
* `takeoff(adapter)` — отвечает за взлет дрона;
* `record(enable)` — отвечает за начало записи видеокамеры на дроне.

Разберем метод `set_mode()` детально:

```python
rospy.wait_for_service(adapter+'/mavros/set_mode')
    try:
        service = rospy.ServiceProxy(adapter+'/mavros/set_mode', SetMode)
        service(0, mode)
```
Из листинга видно, что метод ждет появляения сервиса MAVROS, отвечающего за управления режимами FCU и пытается связаться с ним. Затем сервису отправляется полученное методом значение нового режима. Если все проходит успешно, то метод сигнализирует об этом. В случае неудачи отправляется соответствующее предупреждение.

Разберем метод `arming()` детально:

```python
rospy.wait_for_service(adapter+'/mavros/cmd/arming')
try:
    arm = rospy.ServiceProxy(adapter+'/mavros/cmd/arming', CommandBool)
    arm(True)
```

Из листинга видно, что метод ждет появляения сервиса MAVROS, отвечающего за изменение команды и пытается связаться с ним. Затем сервису отправляется подтверждение изменения команды. Если все проходит успешно, то метод сигнализирует об этом. В случае неудачи отправляется соответствующее предупреждение.

Разберем метод `takeoff()` детально:

```python
rospy.wait_for_service(adapter+'/mavros/cmd/takeoff')
    try:
        takeoff = rospy.ServiceProxy(adapter+'/mavros/cmd/takeoff', CommandTOL)
        takeoff(0,0,0,0,5)
```

Из листинга видно, что метод ждет появляения сервиса MAVROS, отвечающего за взлет дрона и пытается связаться с ним. Затем сервису отправляется набор параметров (тип команды `CommandTOL`): углы рысканья и тангажа, координаты широты и долготы и высота над уровнем моря. Если все проходит успешно, то метод сигнализирует об этом. В случае неудачи отправляется соответствующее предупреждение.

Разберем метод `record()` детально:

```python
rospy.wait_for_service(adapter+'/camera/record')
   try:
       record = rospy.ServiceProxy(adapter+'/camera/record', SetBool;
```

Из листинга видно, что метод ждет появляения сервиса MAVROS, отвечающего за влючение записи с камеры и пытается связаться с ним. Если все проходит успешно, то метод сигнализирует об этом. В случае неудачи отправляется соответствующее предупреждение.

Далее инициализируется узел `drone_master`, который создает соответствующий топик в ROS.

В самом начале определяется метод `drone_adapter()`, который огранизует всю работы по управлению беспилотником. В первую очередь проверяется, подключен ли дрон для выполнения миссии. Если нет, то выполняется описанный выше метод `messenger_drone_free()`:

```python
if adapter in adapters:
            return
        else:
            adapters.append(adapter)
            messenger_drone_free(adapter)
```
Далее выполняется подписка на топик ROS, транслирующий состояние автопилота дрона:

```python
rospy.Subscriber('{0}/mavros/state'.format(adapter), State, drone_state)
```
Кроме того, выполняются подписки на топики, отвечающие за запись видео. Формируется соответствующая ссылка для сохранения данных в IPFS: это выполняет ранее описанная команда messenger_drone_link(), которую оборачиваю в метод `drone_ipfs_link()`:

```python
rospy.Subscriber('{0}/camera/video'.format(adapter), String, drone_ipfs_link)
...
rospy.Subscriber('{0}/camera/thumbnail'.format(adapter), String, drone_ipfs_link)
```

Далее определеяется важный метод `drone_mission()`, который распределяет на выполнение команды, посланные пользователем. В этом учавствует ранее определенный метод организации передвижения БПЛА `messenger_mission_gen()`. Среди команд присутствуют:

* взлететь;
* вернуть БПЛА на место запуска;
* включить режим `AUTO`
* отправить дрона в указанную точку.

В конце выполняется реализация описанного метода `drone_adapter()`:

```python
rospy.Subscriber('/adapter', String, drone_adapter)
```
*Примечание*. Проверить логику методов.
